<!DOCTYPE html>
<html>

<head>
  <title>WAVES</title>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0px;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <script>

    // Resolution of simulation
    const NUM_POINTS = 100;
    // Width of simulation
    const WIDTH = 800;
    // Spring constant for forces applied by adjacent points
    const SPRING_CONSTANT = 0.006;
    // Sprint constant for force applied to baseline
    const SPRING_CONSTANT_BASELINE = 0.006;
    // Vertical draw offset of simulation
    const Y_OFFSET = 200;
    // Damping to apply to speed changes
    const DAMPING = 0.99;

    let sineParameters = (() => {
      let params = []
      let maxAmplitude = 4
      let maxFrequencies = (1 / 16)
      let maxPhases = (2 * Math.PI)

      for (let i = 0; i < NUM_POINTS; ++i) {
        params.push({
          amplitude:  Math.random() * maxAmplitude,
          frequency: Math.random() * maxFrequencies,
          phase:  Math.random() * maxPhases
        })
      }
      return params
    })()

    let wavePoints = (() => {
      let t = [];
      for (let n = 0; n < NUM_POINTS; n++) {
        // This represents a point on the wave
        t.push({
          x: n / NUM_POINTS * WIDTH,
          y: Y_OFFSET,
          spd: {
            y: 0
          }, // speed with vertical component zero
          mass: 1
        });
      }
      return t
    })()

    let offset = 0
    let isPaused = false

    let then, delta

    let mouseMarker = null
    let nearestPoint = null

    let timer = 0

    const sampleSin = (sample, dt) => {
      let result = 0
      dt = dt ? dt : 1
      for (let i = 0; i < NUM_POINTS; ++i) {
        let param = sineParameters[i]
        result += Math.sin(sample * param.frequency + param.phase) * param.amplitude
      }
      return result
    }

    const updateWavePoints = (points, dt, shouldWrapAround) => {

      for (var n = 0; n < points.length; n++) {
        var p = points[n];
        // force to apply to this point
        var force = 0;

        // forces caused by the point immediately to the left or the right
        var forceFromLeft, forceFromRight, forceToBaseline;

        if (n == 0) { // wrap to left-to-right
          forceFromLeft = shouldWrapAround ? SPRING_CONSTANT * (points[points.length - 1].y - p.y) : 0
        } else { // normally
          var dy = points[n - 1].y - p.y;
          forceFromLeft = SPRING_CONSTANT * dy;
        }

        if (n == points.length - 1) { // wrap to right-to-left
          forceFromRight = shouldWrapAround ? SPRING_CONSTANT * (points[0].y - p.y) : 0
        } else { // normally
          var dy = points[n + 1].y - p.y;
          forceFromRight = SPRING_CONSTANT * dy;
        }

        // Also apply force toward the baseline
        var dy = Y_OFFSET - p.y;
        forceToBaseline = SPRING_CONSTANT_BASELINE * dy;

        // Sum up forces
        force = force + forceFromLeft;
        force = force + forceFromRight;
        force = force + forceToBaseline;

        // Calculate acceleration
        var acceleration = force / p.mass;


        // Apply acceleration (with damping)
        p.spd.y = DAMPING * p.spd.y + acceleration;

        // Apply speed
        p.y = p.y + p.spd.y;
      }

    }

    const update = (dt) => {
      timer += dt

      if (timer > 10) {
        offset += 1
      }

      for (let i = 0; i < wavePoints.length; ++i) {
        let currentWP = wavePoints[i]
        currentWP.y += sampleSin(currentWP.x + offset) * (dt / 100)
      }

      updateWavePoints(wavePoints, dt)
    }

    const strokeCircle = (ctx, x, y, radius) => {
      ctx.beginPath()
      ctx.ellipse(x, y, radius, radius, 0, 0, 2 * Math.PI)
      ctx.stroke()
    }

    const strokeLine = (ctx, x, y, ex, ey) => {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(ex, ey);
      ctx.stroke();
    }

    const draw = (ctx) => {
      ctx.clearRect(0, 0, 800, 600)

      ctx.strokeStyle = `Red`
      ctx.lineWidth = 1
      strokeLine(ctx, 0, Y_OFFSET, WIDTH, Y_OFFSET)

      if (mouseMarker != null) {
        let lineLength = 100
        strokeLine(ctx, mouseMarker.x, mouseMarker.y, nearestPoint.x + 5, nearestPoint.y)
      }

      ctx.strokeStyle = "Blue"
      ctx.lineWidth = 4

      for (let i = 0; i < wavePoints.length - 1; ++i) {
        let wavePoint = wavePoints[i]
        let nextWavePoint = wavePoints[i + 1]
        strokeLine(ctx, 5 + wavePoint.x, wavePoint.y, 5 + nextWavePoint.x, nextWavePoint.y)
      }
    }

    const main = () => {
      let canvas = document.getElementById("canvas")
      if (!canvas) {
        throw "CANVAS not there"
      }

      canvas.onmousedown = (ev) => {
        let m = { x: ev.x, y: ev.y }
        let closestDistance = Infinity
        let closestPointIndex = -1

        for (let i = 0; i < wavePoints.length; ++i) {
          let point = wavePoints[i]
          let distance = Math.abs(m.x - point.x)
          if (distance <= closestDistance) {
            closestPointIndex = i
            closestDistance = distance
          }
        }
        if (isFinite(closestDistance)) {
          let nextY = Math.min(m.y, wavePoints[closestPointIndex].y + 200)
          wavePoints[closestPointIndex].y = nextY
          mouseMarker = m
          nearestPoint = wavePoints[closestPointIndex]
        }
      }

      canvas.onmouseup = () => {
        mouseMarker = null
      }

      window.onblur = () => {
        isPaused = true
      }

      window.onfocus = () => {
        then = undefined
        isPaused = false
      }

      canvas.width = 800
      canvas.height = 600

      let ctx = canvas.getContext('2d')

      const gameLoop = (now) => {
        delta = (now - (then || now))
        then = now
        window.requestAnimationFrame(gameLoop)
        if (isPaused) return

        update(delta)
        draw(ctx)
      }

      window.requestAnimationFrame(gameLoop)
    }

    window.onload = main
  </script>
</body>

</html>